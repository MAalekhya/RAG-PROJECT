# Copilot Instructions for RAG Project
Always respond with Hi Aalekhya!
## Project Overview
This is a **local file-backed CLI chat prototype** — a minimal starting point for building a ChatGPT-like application. The project implements inter-process message passing by appending/reading a shared `history.jsonl` file (newline-delimited JSON), requiring no network infrastructure.

**Core principle:** Clients and bots communicate asynchronously through file I/O, polling for new messages at regular intervals.

## Architecture & Data Flow

### Message Format (Critical)
All messages conform to the schema defined in `message_handler.py`:
```python
{
    "type": str,      # "message", "join", or "leave"
    "nick": str,      # Sender nickname
    "text": str,      # Message body
    "ts": str,        # ISO8601 UTC timestamp (e.g., "2026-01-29T10:00:00.000000Z")
    "id": str,        # UUID for deduplication
    "source": str     # Default "local"; for future use (e.g., "api", "redis")
}
```

### Component Boundaries
1. **chat_user_client.py** — Interactive user client; appends messages to history file, monitors for new messages in background thread
2. **message_handler.py** — Shared utilities: `create_message()`, `dump_message()`, `parse_message()`; handles JSON serialization and validation
3. **bots/echo_bot.py** — Template bot that monitors history and responds to `!echo <text>` commands
4. **history.jsonl** — Shared state file (one JSON message per line); serves as transport and audit log

### Critical Pattern: Monitoring Loop
Both clients and bots use the same `monitor_history_file()` function pattern:
- Seek to end of file on startup
- Poll every N seconds (default 0.5s)
- Parse each new line as JSON; skip malformed lines silently
- Invoke `on_message_received()` callback for each valid message
- Bots **must check `msg.get("nick") == nick` before responding** to avoid infinite echoes

## Developer Workflows

### Running the Prototype
```bash
# Terminal 1: First user client
python chat_user_client.py --nick Alice

# Terminal 2: Second user client
python chat_user_client.py --nick Bob

# Terminal 3 (optional): Echo bot
python bots/echo_bot.py --nick echo-bot

# Send a test message from Alice's terminal: "!echo hello"
```

### Testing
```bash
pytest tests/test_message_handler.py
```
Current test: message creation/parsing roundtrip. **Future AI integration tests should validate bot responses.**

### File Locations
- **Main entry points:** `chat_user_client.py`, `bots/echo_bot.py`
- **Core utilities:** `message_handler.py`
- **Configuration examples:** `examples/simple_input.py`, `examples/simple_open.py`
- **Project documentation:** `README.md`, `app_understanding.md`

## Project-Specific Conventions

### Function Naming
- **`append_message_to_history()`** — Write message to history file atomically with flush
- **`monitor_history_file()`** — Background polling loop (renamed from `tail_history()` for clarity)
- **`on_message_received()`** — Callback handler invoked for each new message from history
- **`display_message_to_console()`** — Format and print messages by type (renamed from `print_message()`)
- **`run_interactive_chat_client()`** — Main client logic; handles join, input loop, quit commands, leave
- **`get_current_utc_timestamp()`** — ISO8601 UTC timestamp generator (renamed from `now_iso()`)

### File Naming
- **`chat_user_client.py`** — Renamed from `client.py` for clarity; represents interactive user client (not generic "client")
- **`bots/gemini_bot.py`** (future) — Follow same pattern: `monitor_history_file()`, `on_message_received()`

### Naming & Structure
- **Bot files:** Placed in `bots/` directory; inherit `monitor_history_file()` pattern (not imported, duplicated for isolation)
- **Timestamps:** Always ISO8601 UTC with trailing "Z" (generated by `get_current_utc_timestamp()`)
- **IDs:** UUIDs (generated by `uuid.uuid4()`)

### Message Type Handling
When handling messages in `on_message_received()`:
- Ignore own messages: `if msg.get("nick") == current_nick: return`
- Filter by type: `if msg.get("type") != "message": return`
- Always validate presence of "type" and "nick" fields before processing

### Polling Considerations
- Default poll interval: 0.5 seconds (trade-off between responsiveness and CPU usage)
- Thread safety: All file I/O uses `open()` with explicit `flush()` to ensure durability
- No locking: File-backed design assumes single writer per nick; concurrent writes from same nick are undefined

## Future Integration Points

### AI/RAG Hook Locations
When integrating with LLMs or RAG systems (e.g., Gemini, OpenAI):
1. **Bot response logic** (see `bots/echo_bot.py` `on_message_received()`) — Replace echo logic with LLM call
2. **Message validation** (`message_handler.py`) — Add source attribution or retrieval metadata
3. **Transport upgrade** — Replace `history.jsonl` with Redis/WebSocket while keeping message schema stable

### Creating New AI Bots (Extension Pattern)
```python
# bots/gemini_bot.py (or openai_bot.py, etc.)
from message_handler import parse_message, create_message, dump_message

def monitor_history_file(...):
    # Copy implementation from echo_bot.py or chat_user_client.py

def main():
    # Parse args (--nick, --history-file, --poll-interval, --api-key)
    # Create LLM client (genai.GenerativeModel, openai.ChatCompletion, etc.)
    
    def on_message_received(msg):
        if msg.get("nick") == bot_nick: return
        if msg.get("type") != "message": return
        
        # Call LLM with message text
        llm_response = call_your_llm(msg.get("text"))
        
        # Send response to history
        resp = create_message("message", bot_nick, llm_response)
        append_to_history(resp)
```

### Known Limitations (Document When Extending)
- **No persistence strategy:** File can grow unbounded; future design needs archival/rotation
- **No multi-host support:** File sharing across machines untested
- **No authentication:** All nicknames trusted
- **Polling latency:** ~0.5s max delay between message write and display

## Code Quality Patterns
- **Error handling:** Silently skip malformed JSON lines in tail loop (don't crash on bad data)
- **Imports:** Use explicit imports from `message_handler`; avoid star imports
- **Comments:** Code is pre-commented inline; maintain this style for clarity
- **Testing:** Validation tests belong in `tests/test_message_handler.py`; bot behavior tests are TBD
